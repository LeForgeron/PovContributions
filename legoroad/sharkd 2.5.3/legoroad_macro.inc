// Title: Lego Road Macro v2.5.3
// Author: Michael Horvath <mikh2161@gmail.com>
// Homepage: http://www.geocities.com/Area51/Quadrant/3864/index.htm
// Created: 2005-02-05
// Updated: 2008-12-24
// This file is licensed under the terms of the CC-LGPL.


//------------------------------------------------------------------------------Description

// This include file contains macros that generate Lego (LDraw) style 
// roads that can be formed into various shapes. There are macros for:
// - creating straight roads;
// - creating elliptical roads;
// - creating spiral roads;
// - creating spline-shaped roads;
// - creating straight roads that intersect at any angle.
//
// Also supported is super-elevation (banking) of the roads. This can be
// enabled/disabled when calling the macros.
//
// There is quite a bit you can do to modify or customize the macros, so
// they don't necessarily need to just be used for Lego models. See the 
// "Dependencies & global variables" section, below, for a full list of 
// configuration settings.


//------------------------------------------------------------------------------Notes

// - All units (width, height, etc.) correspond to those used in LDraw.
// - If super-elevation is disabled, then tilt angles are interpolated 
//   linearly from beginning to end.
// - If you enable superelevation, don't make the curve turn too sharply
//   at the beginning, as the change in banking angle will be abrupt.
// - Each step's banking angle is printed to the "Messages" window when 
//   turn debugging on. You can use this information to determine 
//   whether you've set the speed limit too high or too low.
// - Banking angles should never be more than 7 degrees on normal roads 
//   (5 degrees in icy areas).
// - When using the intersection macro, roads will always be flat. 
//   Tilting and banking intersections is not supported.
// - You can use the embankment feature to model a road's thickness. For
//   instance, placing the "LRoad_FloorObject" object so that it lies 
//   parallel 4 units below the road's surface, and setting the 
//   embankment slope to equal 1, results in the proper thickness for 
//   Lego (LDraw) roads.


//------------------------------------------------------------------------------Formulas

// Superelevation Formula #1:
// 	e + f = V^2 / 15 * r
//	      = v^2 / g * r
// Variables:
// 	e = rate of superelevation (ft/ft)
//	    values range from 0.00 to 0.12 ft/ft.
// 	    (0.08 in areas with snow and ice, such as Virginia)
// 	f = side friction factor
//	    values range from 0.17 to 0.09
// 	V = velocity (mph) (5280 ft/mi)
// 	r = radius of curve (ft)
// 	v = velocity (ft/sec)
// 	g = acceleration of gravity (32.2 ft/sec^2)
//
// Superelevation Formula #2:
// 	tan(theta) = v^2 / rg
// Variables:
// 	theta = banking angle
// 	v = car speed (ft/sec) (mph * 5280/3600 = ft/sec)
// 	r = radius of curvature (ft)
// 	g = acceleration due to gravity (32.2 ft/sec^2)


//------------------------------------------------------------------------------To do

// - Store the tangent vectors at the beginning and end of curves, so 
//   that roads in succession can line up smoothly.
// - Make it so the center stripes are always evenly spaced.
// - Tilt angles are currently only valid if a spline turns in a 
//   counter-clockwise direction. Otherwise, the road is banked in the 
//   wrong direction (i.e. up-side-down).
// - There is an odd twisting when a spline turns at an angle greater 
//   than 90 degrees.
// - Base the curves' tension upon the speed-limit so that the they 
//   change shape to accomadate an optimum the speed of travel.
// - Automatic placement of signposts, structural supports, guard rails,
//   etc.
// - Fill adjacent areas with studs.
// - Make it so that intersections can be non-flat.
// - Provide a means of animating along a given path.
// - Turning lane markers at intersections. (This would make the road 
//   highly "unofficial" from a purist's standpoint.)
// - Do two passes through each main loop: one to pre-calculate and 
//   store values in arrays; another to retrieve the stored values and 
//   put them into effect. This is speedier than repeatedly calculating 
//   the same values in each loop.
// - There are some minor texture clipping issues in flat intersections 
//   when only two roads intersect at a very tight angle.


//------------------------------------------------------------------------------Includes & macros

#include "math.inc"
#include "transforms.inc"

#macro LRoad_LDrawTexture(vColor)
	// Material code generated by L3P by Lars C. Hassing.
	#ifndef (QUAL)		#local QUAL =		3;				#end
	#ifndef (BUMPS)		#local BUMPS =		1;				#end
	#ifndef (BUMPNORMAL)	#local BUMPNORMAL =	normal {bumps 0.01 scale 20}	#end
	#ifndef (AMB)		#local AMB =		0.4;				#end
	#ifndef (DIF)		#local DIF =		0.4;				#end
	texture
	{
		pigment {color rgb vColor}
		finish {ambient AMB diffuse DIF}
		#if (QUAL > 1)
			finish {phong 0.5 phong_size 40 reflection 0.08}
			#if (BUMPS)
				normal {BUMPNORMAL}
			#end
		#end
	}
#end


// ===== 1 ======= 2 ======= 3 ======= 4 ======= 5 ======= 6 ======= 7
// Copyright Tor Olav Kristensen
// http://subcube.com
// ===== 1 ======= 2 ======= 3 ======= 4 ======= 5 ======= 6 ======= 7

// Projection of the vector v1 in the direction  of the vector v2.
#macro LRoad_vproject(v1, v2)
	v2 * vdot(v1, v2)/vdot(v2, v2)
#end

#macro LRoad_inv_vproject(v1, v2)
	v2/vdot(v2, v1) * vdot(v1, v1)
#end

// Find the two points on the lines which is closest to each other
#macro LRoad_ln2ln(pLine1, vLine1, pLine2, vLine2)
	#local vPN = pLine2 - pLine1;
	#local vPQ = vPN - LRoad_vproject(vPN, vcross(vLine1, vLine2));
	#local vQS = LRoad_inv_vproject(LRoad_vproject(vPQ, vLine1) - vPQ, vLine2);
	array[2] {pLine1 + vQS + vPQ, pLine2 + vQS,}
#end


//------------------------------------------------------------------------------Dependencies & global variables

#ifndef (LRoad_Debug)		#declare LRoad_Debug =			0;						#end	// The level of debug information.							(integer)
																// ... 0 = off; 1 = text only; 2 = text and marker objects.
#ifndef (LRoad_DebugSize)	#declare LRoad_DebugSize =		8;						#end	// The default size of debug objects.							(float)

#ifndef (LRoad_FudgeAmount)	#declare LRoad_FudgeAmount =		100000;						#end	// The value used for "fudging" distances so that coincident objects don't overlap.	(float)

#ifndef (LRoad_RoadWidth)	#declare LRoad_RoadWidth =		array[3] {280,306,360,};			#end	// The width of the road.								(float)

#ifndef (LRoad_RoadThickness)	#declare LRoad_RoadThickness =		array[3] {004,004,004,};			#end	// The thickness of the road.								(float)
																// ... Not currently used. To model road thickness, use the embankment feature, below.
#ifndef (LRoad_StripeInterval)	#declare LRoad_StripeInterval =		array[3] {064,064,064,};			#end	// The distance between each stripe-interval.						(float)

#ifndef (LRoad_ShoulderWidth)	#declare LRoad_ShoulderWidth =		array[3] {023,036,063,};			#end	// The distance from the outer edge of the road to the inner edge of the innermost shoulder stripe.	(float)
																// ... Ignored if the road type is 0.
#ifndef (LRoad_BevelRadius)	#declare LRoad_BevelRadius =		array[3] {000,000,010,};			#end	// The inner radius of the curve at intersections.					(float)
																// ... Only applies to flat intersections.
#ifndef (LRoad_WalkDistance)	#declare LRoad_WalkDistance =		array[3] {052,039,012,};			#end	// The distance from the intersection to the center of the crosswalk.			(float)
																// ... Only applies to flat intersections.
#ifndef (LRoad_WalkLength)	#declare LRoad_WalkLength =		array[3] {234,234,234,};			#end	// The width of the crosswalk.								(float)
																// ... Only applies to flat intersections.
#ifndef (LRoad_WalkWidth)	#declare LRoad_WalkWidth =		array[3] {060,060,060,};			#end	// The length of the crosswalk.								(float)
																// ... Only applies to flat intersections.
#ifndef (LRoad_WalkInterval)	#declare LRoad_WalkInterval =		array[3] {025,025,025,};			#end	// The width of a crosswalk stripe.							(float)
																// ... Only applies to flat intersections.
#ifndef (LRoad_DistanceUnit)	#declare LRoad_DistanceUnit = 		10;						#end	// The unit of distance equivalent to 1 foot.						(float)
																// ... Used when determining superelevation.
#ifndef (LRoad_SkyVector)	#declare LRoad_SkyVector = 		y;						#end	// The direction of the sky.								(vector)
																// ... Does not apply to flat intersections.
#ifndef (LRoad_WallSlope)	#declare LRoad_WallSlope =		2/1;						#end	// The slope of the embankment walls.							(float)

#ifndef (LRoad_FloorObject)	#declare LRoad_FloorObject =		plane {LRoad_SkyVector, 0}			#end	// The object that is considered the ground.						(object)

#ifndef (LRoad_RoadSurfaceTexture)	#declare LRoad_RoadSurfaceTexture =		LRoad_LDrawTexture(<0.682353,0.682353,0.682353,>);	#end	// The principal texture of the road surface.			(texture)
#ifndef (LRoad_CrosswalkTexture)	#declare LRoad_CrosswalkTexture =		LRoad_LDrawTexture(1);					#end	// The crosswalk texture.					(texture)
#ifndef (LRoad_CenterStripeTexture)	#declare LRoad_CenterStripeTexture =		LRoad_LDrawTexture(1);					#end	// The center stripe texture.					(texture)
#ifndef (LRoad_InnerStripeTexture)	#declare LRoad_InnerStripeTexture =		LRoad_LDrawTexture(<0.117647,0.627451,0.227451,>);	#end	// The inner shoulder stripe texture.				(texture)
#ifndef (LRoad_OuterStripeTexture)	#declare LRoad_OuterStripeTexture =		LRoad_LDrawTexture(1);					#end	// The outer shoulder stripe texture.				(texture)
#ifndef (LRoad_TransparentTexture)	#declare LRoad_TransparentTexture =		texture {pigment {color rgbt 1}};			#end	// The transparency texture.					(texture)
#ifndef (LRoad_EmbankmentTexture)	#declare LRoad_EmbankmentTexture =		LRoad_LDrawTexture(<0.682353,0.682353,0.682353,>);	#end	// The embankment texture.					(texture)


//------------------------------------------------------------------------------Materials

#macro LRoad_RoadSurface(roadTyp)
	texture_map
	{
		#switch (roadTyp)
			#case (0)
				[000/280 LRoad_RoadSurfaceTexture]
				[007/280 LRoad_RoadSurfaceTexture]
				[007/280 LRoad_InnerStripeTexture]
				[023/280 LRoad_InnerStripeTexture]
				[023/280 LRoad_RoadSurfaceTexture]
				[257/280 LRoad_RoadSurfaceTexture]
				[257/280 LRoad_InnerStripeTexture]
				[273/280 LRoad_InnerStripeTexture]
				[273/280 LRoad_RoadSurfaceTexture]
				[280/280 LRoad_RoadSurfaceTexture]
			#break
			#case (1)
				[000/306 LRoad_RoadSurfaceTexture]
				[020/306 LRoad_RoadSurfaceTexture]
				[020/306 LRoad_InnerStripeTexture]
				[036/306 LRoad_InnerStripeTexture]
				[036/306 LRoad_RoadSurfaceTexture]
				[270/306 LRoad_RoadSurfaceTexture]
				[270/306 LRoad_InnerStripeTexture]
				[286/306 LRoad_InnerStripeTexture]
				[286/306 LRoad_RoadSurfaceTexture]
				[306/306 LRoad_RoadSurfaceTexture]
			#break
			#case (2)
				[000/360 LRoad_RoadSurfaceTexture]
				[002/360 LRoad_RoadSurfaceTexture]
				[002/360 LRoad_OuterStripeTexture]
				[012/360 LRoad_OuterStripeTexture]
				[012/360 LRoad_RoadSurfaceTexture]
				[047/360 LRoad_RoadSurfaceTexture]
				[047/360 LRoad_InnerStripeTexture]
				[063/360 LRoad_InnerStripeTexture]
				[063/360 LRoad_RoadSurfaceTexture]
				[297/360 LRoad_RoadSurfaceTexture]
				[297/360 LRoad_InnerStripeTexture]
				[313/360 LRoad_InnerStripeTexture]
				[313/360 LRoad_RoadSurfaceTexture]
				[348/360 LRoad_RoadSurfaceTexture]
				[348/360 LRoad_OuterStripeTexture]
				[358/360 LRoad_OuterStripeTexture]
				[358/360 LRoad_RoadSurfaceTexture]
				[360/360 LRoad_RoadSurfaceTexture]
			#break
		#end
	}
#end
#macro LRoad_StripeSurface(roadTyp)
	texture_map
	{
		#switch (roadTyp)
			#case (0)
			#case (1)
			#case (2)
				[00/64 LRoad_CenterStripeTexture]
				[20/64 LRoad_CenterStripeTexture]
				[20/64 LRoad_RoadSurfaceTexture]
				[44/64 LRoad_RoadSurfaceTexture]
				[44/64 LRoad_CenterStripeTexture]
				[64/64 LRoad_CenterStripeTexture]
			#break
		#end
	}
#end
#macro LRoad_RoadMap(roadTyp, roadSurface, stripeSurface)
	texture_map
	{
		#switch (roadTyp)
			#case (0)
				[000/280 roadSurface]
				[134/280 roadSurface]
				[134/280 stripeSurface]
				[146/280 stripeSurface]
				[146/280 roadSurface]
				[280/280 roadSurface]
			#break
			#case (1)
				[000/306 roadSurface]
				[147/306 roadSurface]
				[147/306 stripeSurface]
				[159/306 stripeSurface]
				[159/306 roadSurface]
				[306/306 roadSurface]
			#break
			#case (2)
				[000/360 roadSurface]
				[174/360 roadSurface]
				[174/360 stripeSurface]
				[186/360 stripeSurface]
				[186/360 roadSurface]
				[360/360 roadSurface]
			#break
		#end
	}
#end
#macro LRoad_WalkSurface(roadTyp)
	texture_map
	{
		#switch (roadTyp)
			#case (0)
			#case (1)
			#case (2)
				[00/25 LRoad_CrosswalkTexture]
				[08/25 LRoad_CrosswalkTexture]
				[08/25 LRoad_RoadSurfaceTexture]
				[17/25 LRoad_RoadSurfaceTexture]
				[17/25 LRoad_CrosswalkTexture]
				[25/25 LRoad_CrosswalkTexture]
			#break
		#end
	}
#end
#macro LRoad_InnerCornerSurface(roadTyp, radiusVal)
	texture_map
	{
		#switch (roadTyp)
			#case (0)
			#break
			#case (1)
				[0 LRoad_RoadSurfaceTexture]
				[(270+radiusVal)/(306+radiusVal*2) LRoad_RoadSurfaceTexture]
				[(270+radiusVal)/(306+radiusVal*2) LRoad_InnerStripeTexture]
				[(286+radiusVal)/(306+radiusVal*2) LRoad_InnerStripeTexture]
				[(286+radiusVal)/(306+radiusVal*2) LRoad_RoadSurfaceTexture]
				[(306+radiusVal)/(306+radiusVal*2) LRoad_RoadSurfaceTexture]
				[(306+radiusVal)/(306+radiusVal*2) LRoad_TransparentTexture]
				[1 LRoad_TransparentTexture]
			#break
			#case (2)
				[0 LRoad_RoadSurfaceTexture]
				[(297+radiusVal)/(360+radiusVal*2) LRoad_RoadSurfaceTexture]
				[(297+radiusVal)/(360+radiusVal*2) LRoad_InnerStripeTexture]
				[(313+radiusVal)/(360+radiusVal*2) LRoad_InnerStripeTexture]
				[(313+radiusVal)/(360+radiusVal*2) LRoad_RoadSurfaceTexture]
				[(348+radiusVal)/(360+radiusVal*2) LRoad_RoadSurfaceTexture]
				[(348+radiusVal)/(360+radiusVal*2) LRoad_OuterStripeTexture]
				[(358+radiusVal)/(360+radiusVal*2) LRoad_OuterStripeTexture]
				[(358+radiusVal)/(360+radiusVal*2) LRoad_RoadSurfaceTexture]
				[(360+radiusVal)/(360+radiusVal*2) LRoad_RoadSurfaceTexture]
				[(360+radiusVal)/(360+radiusVal*2) LRoad_TransparentTexture]
				[1 LRoad_TransparentTexture]
			#break
		#end
	}
#end
#macro LRoad_OuterCornerSurface(roadTyp, radiusVal)
	texture_map
	{
		#switch (roadTyp)
			#case (0)
			#break
			#case (1)
				[0 LRoad_TransparentTexture]
				[(000+radiusVal)/(306+radiusVal*2) LRoad_TransparentTexture]
				[(000+radiusVal)/(306+radiusVal*2) LRoad_RoadSurfaceTexture]
				[(020+radiusVal)/(306+radiusVal*2) LRoad_RoadSurfaceTexture]
				[(020+radiusVal)/(306+radiusVal*2) LRoad_InnerStripeTexture]
				[(036+radiusVal)/(306+radiusVal*2) LRoad_InnerStripeTexture]
				[(036+radiusVal)/(306+radiusVal*2) LRoad_RoadSurfaceTexture]
				[1 LRoad_RoadSurfaceTexture]
			#break
			#case (2)
				[0 LRoad_TransparentTexture]
				[(000+radiusVal)/(360+radiusVal*2) LRoad_TransparentTexture]
				[(000+radiusVal)/(360+radiusVal*2) LRoad_RoadSurfaceTexture]
				[(002+radiusVal)/(360+radiusVal*2) LRoad_RoadSurfaceTexture]
				[(002+radiusVal)/(360+radiusVal*2) LRoad_OuterStripeTexture]
				[(012+radiusVal)/(360+radiusVal*2) LRoad_OuterStripeTexture]
				[(012+radiusVal)/(360+radiusVal*2) LRoad_RoadSurfaceTexture]
				[(047+radiusVal)/(360+radiusVal*2) LRoad_RoadSurfaceTexture]
				[(047+radiusVal)/(360+radiusVal*2) LRoad_InnerStripeTexture]
				[(063+radiusVal)/(360+radiusVal*2) LRoad_InnerStripeTexture]
				[(063+radiusVal)/(360+radiusVal*2) LRoad_RoadSurfaceTexture]
				[1 LRoad_RoadSurfaceTexture]
			#break
		#end
	}
#end
#macro LRoad_StraightCornerSurface(roadTyp, sSurface, pSurface)
	texture_map
	{
		#switch (roadTyp)
			#case (0)
				[0/2 sSurface]
				[1/2 sSurface]
				[1/2 pSurface]
				[2/2 pSurface]
			#break
			#case (1)
			#break
			#case (2)
			#break
		#end
	}
#end
#macro LRoad_StraightEdgeSurface_s1(roadTyp)
	texture_map
	{
		#switch (roadTyp)
			#case (0)
				[000/280 LRoad_TransparentTexture]
				[257/280 LRoad_TransparentTexture]
				[257/280 LRoad_InnerStripeTexture]
				[273/280 LRoad_InnerStripeTexture]
				[273/280 LRoad_RoadSurfaceTexture]
				[280/280 LRoad_RoadSurfaceTexture]
			#break
			#case (1)
			#break
			#case (2)
			#break
		#end
	}
#end
#macro LRoad_StraightEdgeSurface_p1(roadTyp)
	texture_map
	{
		#switch (roadTyp)
			#case (0)
				[000/280 LRoad_RoadSurfaceTexture]
				[007/280 LRoad_RoadSurfaceTexture]
				[007/280 LRoad_InnerStripeTexture]
				[023/280 LRoad_InnerStripeTexture]
				[023/280 LRoad_TransparentTexture]
				[280/280 LRoad_TransparentTexture]
			#break
			#case (1)
			#break
			#case (2)
			#break
		#end
	}
#end
#macro LRoad_StraightEdgeSurface_s2(roadTyp)
	texture_map
	{
		#switch (roadTyp)
			#case (0)
				[000/280 LRoad_RoadSurfaceTexture]
				[257/280 LRoad_RoadSurfaceTexture]
				[257/280 LRoad_InnerStripeTexture]
				[273/280 LRoad_InnerStripeTexture]
				[273/280 LRoad_RoadSurfaceTexture]
				[280/280 LRoad_RoadSurfaceTexture]
			#break
			#case (1)
			#break
			#case (2)
			#break
		#end
	}
#end
#macro LRoad_StraightEdgeSurface_p2(roadTyp)
	texture_map
	{
		#switch (roadTyp)
			#case (0)
				[000/280 LRoad_RoadSurfaceTexture]
				[007/280 LRoad_RoadSurfaceTexture]
				[007/280 LRoad_InnerStripeTexture]
				[023/280 LRoad_InnerStripeTexture]
				[023/280 LRoad_RoadSurfaceTexture]
				[280/280 LRoad_RoadSurfaceTexture]
			#break
			#case (1)
			#break
			#case (2)
			#break
		#end
	}
#end


//------------------------------------------------------------------------------Shape formula macros

#macro LRoad_Pos_Straight(V,O,TS)
	V*TS+O
#end
#macro LRoad_Pos_Ellipse(H,M1,M2,T1,T2,TS)
	#local perc = TS*(T2-T1)+T1;
	#local step = 2*pi*perc;
	<cos(step)*M1,H*perc,sin(step)*M2,>
#end
#macro LRoad_Pos_Nautilus(H,D,A,R,T1,T2,TS)
	#local perc = TS*(T2-T1)+T1;
	#local step = 2*pi*perc;
	<R*exp(step/tan(A))*cos(step),H*perc,R*exp(step/tan(A))*sin(step),>*D
#end
#macro LRoad_Pos_Archimedes(H,D,R,T1,T2,TS)
	#local perc = TS*(T2-T1)+T1;
	#local step = 2*pi*perc;
	<R*cos(step)*perc,H*perc,R*sin(step)*perc,>*D
#end
#macro LRoad_Pos_Spline(O1,T1,O2,T2,TS)
	#local V1 = T1 - O1;
	#local V2 = T2 - O2;
	#local h1 = +2*pow(TS,3)-3*pow(TS,2)+1;
	#local h2 = -2*pow(TS,3)+3*pow(TS,2)+0;
	#local h3 = +1*pow(TS,3)-2*pow(TS,2)+pow(TS,1);
	#local h4 = +1*pow(TS,3)-1*pow(TS,2)+0;
	O1*h1+O2*h2+V1*h3+V2*h4
#end


//------------------------------------------------------------------------------Flat intersection macro

#macro LRoad_Intersection_Macro
	(
		roadCoo,	// An array of vectors containing the starting points of the intersecting roads.	(array)
				// ... There can be as many as you want. List them in clockwise order when looking down from the top.
				// ... Since the intersections are flat, the vectors are two-dimensional instead of three-dimensional, and contain only the x and z coordinates.
				// ... Make sure to increment the array counter when adding or subtracting elements.
		roadHgh,	// The height of the road above the x-z plane.						(float)
		roadTyp,	// The type of road. 0 = "9-Stud"; 1 = "8-Stud"; 2 = "7-Stud".				(integer)
		showCrs,	// Enable/disable crosswalks.								(boolean)
		showBed,	// Enable/disable road embankments.							(boolean)
	)

	#if (LRoad_Debug > 0)
		#debug "\n"
	#end
	#if (roadTyp > 2)
		#error "The type of road must be 0, 1 or 2.\n"
	#end
	#if ((showBed > 1) | (showBed < 0))
		#error "Disable/Enable embankments by specifying 0 or 1, on or off, yes or no.\n"
	#end
	#if ((showCrs > 1) | (showCrs < 0))
		#error "Disable/Enable crosswalks by specifying 0 or 1, on or off, yes or no.\n"
	#end

	//------------------------------------------------------------------------------Variables

	#local roadNum =		dimension_size(roadCoo, 1);		// The number of roads that will intersect at the origin.
	#local RoadWidth =		LRoad_RoadWidth[roadTyp];		// The width of the road.
	#local StripeInterval =		LRoad_StripeInterval[roadTyp];		// The distance between each stripe-interval.
	#local ShoulderWidth =		LRoad_ShoulderWidth[roadTyp];		// The distance from the outer edge of the road to the inner edge of the innermost shoulder stripe.
	#local BevelRadius =		LRoad_BevelRadius[roadTyp];		// The inner radius of the curve at intersections.
	#local WalkDist =		LRoad_WalkDistance[roadTyp];		// The distance from the intersection to the center of a crosswalk.
	#local WalkLength =		LRoad_WalkLength[roadTyp];		// The width of the crosswalk.
	#local WalkWidth =		LRoad_WalkWidth[roadTyp];		// The length of the crosswalk.
	#local WalkInterval =		LRoad_WalkInterval[roadTyp];		// The width of a crosswalk stripe.
	#local SlopeAngle = 		90 - atan2d(LRoad_WallSlope, 1);	// The angle of the embankment's slope.
	#local RoadHalf =		RoadWidth / 2;				// Half the width of the road.
	#local ShoulderHalf =		ShoulderWidth / 2;			// Half the width of the shoulder.
	#local ShoulderOppo =		RoadWidth - ShoulderHalf;
	#local WalkHalf =		WalkLength / 2;				// Half the width of the crosswalk.
	#local PlaneMask = intersection
	{
		plane  {+y, 0}
		plane  {-y, 0}
	}
	#local BedMask = intersection						// Object that determines the minimum and maximum height of the road, including the embankment.
	{
		plane  {+y, 0}
		object {LRoad_FloorObject translate -y * roadHgh inverse}
	}

	#local      aLargeObjects = array[roadNum];
	#local        aGapObjects = array[roadNum];
	#local     aCenterObjects = array[roadNum];
	#local       aEdgeObjects = array[roadNum];
	#local     aCornerObjects = array[roadNum];
	#local       aWalkObjects = array[roadNum];
	#local  aCornerCutObjects = array[roadNum];
	#local   aWallMainObjects = array[roadNum];
	#local aWallCenterObjects = array[roadNum];
	#local   aWallCutObjectsA = array[roadNum];
	#local   aWallCutObjectsB = array[roadNum];
	#local aWallCornerObjects = array[roadNum];
	#local     aLargeTextures = array[roadNum];
	#local       aGapTextures = array[roadNum];
	#local    aCenterTextures = array[roadNum];
	#local      aEdgeTextures = array[roadNum];
	#local    aCornerTextures = array[roadNum];
	#local      aWalkTextures = array[roadNum];
	#local       aEdgeLengths = array[roadNum];
	#local       aStopLengths = array[roadNum];
	#local     aParallelFlags = array[roadNum];
	#local        aSideAngles = array[roadNum];

	#if (roadNum < 2)
		#error "There must be at least two roads in an intersection.\n"
	#end


	//------------------------------------------------------------------------------Intersection generation

	union
	{
		#local sRoad = 0;
		#while (sRoad < roadNum)


			//------------------------------------------------------------------------------Calculations

			#local ppRoad = sRoad - 2;
			#if (ppRoad < 0)
				#local ppRoad = ppRoad + roadNum;
			#end
			#local  pRoad = sRoad - 1;
			#if ( pRoad < 0)
				#local  pRoad =  pRoad + roadNum;
			#end
			#local  nRoad = sRoad + 1;
			#if ( nRoad >= roadNum)
				#local  nRoad =  nRoad - roadNum;
			#end
			#local nnRoad = sRoad + 2;
			#if (nnRoad >= roadNum)
				#local nnRoad = nnRoad - roadNum;
			#end

			#local ppStart = <roadCoo[ppRoad].u, 0, roadCoo[ppRoad].v,>;
			#local  pStart = <roadCoo[ pRoad].u, 0, roadCoo[ pRoad].v,>;
			#local  sStart = <roadCoo[ sRoad].u, 0, roadCoo[ sRoad].v,>;
			#local  nStart = <roadCoo[ nRoad].u, 0, roadCoo[ nRoad].v,>;
			#local nnStart = <roadCoo[nnRoad].u, 0, roadCoo[nnRoad].v,>;

			#local ppAngle = VRotationD( pStart,ppStart,y);
			#if (ppAngle < 0)
				#local ppAngle = 360 + ppAngle;
			#end
			#local  pAngle = VRotationD( sStart, pStart,y);
			#if ( pAngle < 0)
				#local  pAngle = 360 +  pAngle;
			#end
			#local  sAngle = VRotationD( nStart, sStart,y);
			#if ( sAngle < 0)
				#local  sAngle = 360 +  sAngle;
			#end
			#local  nAngle = VRotationD(nnStart, nStart,y);
			#if ( nAngle < 0)
				#local  nAngle = 360 +  nAngle;
			#end

			#local ppTangent = vnormalize(ppStart);
			#local  pTangent = vnormalize( pStart);
			#local  sTangent = vnormalize( sStart);
			#local  nTangent = vnormalize( nStart);
			#local nnTangent = vnormalize(nnStart);

			#local ppPlane = vnormalize(vcross(ppTangent, y));
			#local  pPlane = vnormalize(vcross( pTangent, y));
			#local  sPlane = vnormalize(vcross( sTangent, y));
			#local  nPlane = vnormalize(vcross( nTangent, y));
			#local nnPlane = vnormalize(vcross(nnTangent, y));

			#local ppBevelAdjust = BevelRadius * tand(90 - ppAngle / 2);
			#local  pBevelAdjust = BevelRadius * tand(90 -  pAngle / 2);
			#local  sBevelAdjust = BevelRadius * tand(90 -  sAngle / 2);
			#local  nBevelAdjust = BevelRadius * tand(90 -  nAngle / 2);

			#if (VEq( pTangent, +ppTangent) | VEq( pTangent, -ppTangent))
				#local ppIntersect = +ppPlane * RoadHalf;
				#local  ppParallel = 1;
			#else
				#local   temparray = LRoad_ln2ln(ppStart + ppPlane * RoadHalf, ppTangent,  pStart -  pPlane * RoadHalf,  pTangent);
				#local ppIntersect = temparray[0];
				#local  ppParallel = 0;
			#end
			#if (VEq( sTangent,  +pTangent) | VEq( sTangent,  -pTangent))
				#local  pIntersect =  +pPlane * RoadHalf;
				#local   pParallel = 1;
			#else
				#local   temparray = LRoad_ln2ln( pStart +  pPlane * RoadHalf,  pTangent,  sStart -  sPlane * RoadHalf,  sTangent);
				#local  pIntersect = temparray[0];
				#local   pParallel = 0;
			#end
			#if (VEq( nTangent,  +sTangent) | VEq( nTangent,  -sTangent))
				#local  sIntersect =  +sPlane * RoadHalf;
				#local   sParallel = 1;
			#else
				#local   temparray = LRoad_ln2ln( sStart +  sPlane * RoadHalf,  sTangent,  nStart -  nPlane * RoadHalf,  nTangent);
				#local  sIntersect = temparray[0];
				#local   sParallel = 0;
			#end
			#if (VEq(nnTangent,  +nTangent) | VEq(nnTangent,  -nTangent))
				#local  nIntersect =  +nPlane * RoadHalf;
				#local   nParallel = 1;
			#else
				#local   temparray = LRoad_ln2ln( nStart +  nPlane * RoadHalf,  nTangent, nnStart - nnPlane * RoadHalf, nnTangent);
				#local  nIntersect = temparray[0];
				#local   nParallel = 0;
			#end

			#local sPrvIntersect = vaxis_rotate(ppIntersect, y, -pAngle);
			#local sNxtIntersect = vaxis_rotate( nIntersect, y, +sAngle);
			#local spDistance = VDist(sStart,    pIntersect + sPlane * RoadHalf);
			#local ssDistance = VDist(sStart,    sIntersect - sPlane * RoadHalf);
			#local snDistance = VDist(sStart, sNxtIntersect - sPlane * RoadHalf);
			#local sMinDistance = min(spDistance, ssDistance);
			#local sMaxDistance = max(spDistance, ssDistance);

			#if (sMinDistance = spDistance)
				#local        sMinCase = +1;
				#local   sMinIntersect = pIntersect;
				#local sMinBevelAdjust = pBevelAdjust;
				#local   sMaxIntersect = sIntersect;
				#local sMaxBevelAdjust = sBevelAdjust;
			#else
				#local        sMinCase = -1;
				#local   sMinIntersect = sIntersect;
				#local sMinBevelAdjust = sBevelAdjust;
				#local   sMaxIntersect = pIntersect;
				#local sMaxBevelAdjust = pBevelAdjust;
			#end

			#local sMinEdge = sMinIntersect + sMinCase * sPlane * ShoulderOppo;
			#local sMinStop = sMinIntersect + sMinCase * sPlane * RoadHalf;
			#local sMaxEdge = sMaxIntersect - sMinCase * sPlane * ShoulderHalf;
			#local sMaxStop = sMaxIntersect - sMinCase * sPlane * RoadHalf;
			#local sPrvEdge = sPrvIntersect + sPlane * ShoulderHalf;
			#local sPrvStop = sPrvIntersect + sPlane * RoadHalf;
			#local sNxtEdge = sNxtIntersect - sPlane * ShoulderHalf;
			#local sNxtStop = sNxtIntersect - sPlane * RoadHalf;
			#local sCalIntercept = sMaxIntersect;

			#if (sAngle > 180)
				#if ((sMaxDistance > snDistance) & (sMinDistance <= snDistance))
					#local sCalcCase = -1;
					#local sCalIntercept = sNxtIntersect +    nBevelAdjust * sTangent;
				#else
					#local sCalcCase = sMinCase;
					#local sCalIntercept = sMinIntersect + sMinBevelAdjust * sTangent;
				#end
			#end
			#if (pAngle > 180)
				#if ((sMaxDistance > snDistance) & (sMinDistance <= snDistance))
					#local sCalcCase = +1;
					#local sCalIntercept = sPrvIntersect +   ppBevelAdjust * sTangent;
				#else
					#local sCalcCase = sMinCase;
					#local sCalIntercept = sMinIntersect + sMinBevelAdjust * sTangent;
				#end
			#end
			#if ((pParallel = 1) & (sParallel = 1))
				#local sCalIntercept = -sPlane * RoadHalf;
			#end

			// Corners
			#if (pAngle > 180)
				#if (sCalcCase = 1)
					#local spBevel = sCalIntercept;
				#else
					#local spBevel = sCalIntercept - RoadWidth * sPlane;
				#end
				#if (pParallel | sParallel)
					#local spBevel = pIntersect;
				#end
				#local psBevel = vaxis_rotate(spBevel, y, pAngle) + RoadWidth * pPlane;
			#else
				#local spBevel = pIntersect + pBevelAdjust * sTangent;
				#local psBevel = pIntersect + pBevelAdjust * pTangent;
			#end
			#local sCornerPt1 = spBevel + ShoulderWidth * sPlane;
			#local sCornerPt2 = psBevel - ShoulderWidth * pPlane;
			#local  temparray = LRoad_ln2ln(sCornerPt1, sTangent, sCornerPt2, pTangent);
			#local sCornerPt3 = temparray[0];
			#local sCornerPt4 = -pIntersect;
			#local  temparray = LRoad_ln2ln(spBevel, sPlane, psBevel, pPlane);
			#local pArcCenter = temparray[0];
			#local pArcRadius = VDist(spBevel, pArcCenter);
			#if (pAngle > 180)
				#local pRadius = pArcRadius - RoadWidth;
			#else
				#local pRadius = BevelRadius;
			#end
			#local sCornerTangent = vnormalize((sTangent + pTangent) / 2);
			#local sCornerPlane = sTangent - pTangent;
			#local sCornerInside = pIntersect;

			// Crosswalk
			#local sCrosswalkPt1 = sMinStop + WalkHalf * sPlane + WalkDist * sTangent;
			#local sCrosswalkPt2 = sMinStop - WalkHalf * sPlane + WalkDist * sTangent;

			// Main, gap & center road sections
			#local sRoadMainPt1 = sMinStop + WalkDist * sTangent + WalkWidth / 2 * sTangent;
			#local sRoadMainPt2 = sMinStop + sMinBevelAdjust * sTangent;
			#local sRoadMainPt3 = sCalIntercept + sPlane * RoadHalf;
			#if ((pParallel = 1) | (sParallel = 1))
				#local sRoadMainPt3 = 0;
			#end

			// Edge sections
			#local sRoadEdgePt1 = sMinEdge + sMinBevelAdjust * sTangent;
			#local sRoadEdgePt2 = sMaxEdge + sMaxBevelAdjust * sTangent;
			#if (pAngle > 180)
				#if (sCalcCase = 1)
					#local sRoadEdgePt2 = sCalIntercept + sPlane * ShoulderHalf;
				#else
					#local sRoadEdgePt2 = sCalIntercept - sPlane * ShoulderOppo;
				#end
			#end
			#if (sAngle > 180)
				#if (sCalcCase = 1)
					#local sRoadEdgePt2 = sCalIntercept + sPlane * ShoulderOppo;
				#else
					#local sRoadEdgePt2 = sCalIntercept - sPlane * ShoulderHalf;
				#end
			#end
			#if (pParallel = 1)
				#local sRoadEdgePt2 = -sPlane * (RoadHalf - ShoulderHalf);
			#end
			#if (sParallel = 1)
				#local sRoadEdgePt2 = +sPlane * (RoadHalf - ShoulderHalf);
			#end
			#local sEdgeLength = VDist(sRoadEdgePt1, sRoadEdgePt2);

			// Center road
			#local sStopLength = vlength(sMinStop);

			// Arrays
			#local   aEdgeLengths[sRoad] = sEdgeLength;
			#local   aStopLengths[sRoad] = sStopLength;
			#local aParallelFlags[sRoad] =   pParallel;
			#local    aSideAngles[sRoad] =      pAngle;


			//----------------------------------------------------------------------------Textures

			#local sStripeSurface = texture
			{
				gradient sTangent
				LRoad_StripeSurface(roadTyp)
				scale StripeInterval/RoadWidth
			}
			#local sRoadSurface = texture
			{
				gradient sPlane
				LRoad_RoadSurface(roadTyp)
			}
			#local sLargeSurface = texture
			{
				gradient sPlane
				LRoad_RoadMap(roadTyp, sRoadSurface, sStripeSurface)
			}
			#if (pParallel = 0)
				#if (roadTyp = 0)
					#local sEdgeSurface1 = texture
					{
						gradient -sPlane
						LRoad_StraightEdgeSurface_s1(roadTyp)
						scale 1/4
					}
					#local pEdgeSurface1 = texture
					{
						gradient -pPlane
						LRoad_StraightEdgeSurface_p1(roadTyp)
						scale 1/4
					}
					#local sEdgeSurface2 = texture
					{
						gradient -sPlane
						LRoad_StraightEdgeSurface_s2(roadTyp)
						scale 1/4
					}
					#local pEdgeSurface2 = texture
					{
						gradient -pPlane
						LRoad_StraightEdgeSurface_p2(roadTyp)
						scale 1/4
					}
					#local sCornerSurface = texture
					{
						gradient sCornerPlane
						#if (pAngle > 180)
							LRoad_StraightCornerSurface(roadTyp, sEdgeSurface2, pEdgeSurface2)
						#else
							LRoad_StraightCornerSurface(roadTyp, sEdgeSurface1, pEdgeSurface1)
						#end
						scale 4
					}
				#else
					#local sCornerSurface = texture
					{
						cylindrical
						#if (pAngle > 180)
							LRoad_OuterCornerSurface(roadTyp, pRadius)
						#else
							LRoad_InnerCornerSurface(roadTyp, pRadius)
						#end
					}
				#end
			#end
			#if (showCrs)
				#local sWalkSurface = texture
				{
					gradient sPlane
					LRoad_WalkSurface(roadTyp)
				}
			#end
			#local sWallSurface = texture
			{
				LRoad_EmbankmentTexture
			}


			//----------------------------------------------------------------------------Objects

			// large road sections
			#local aLargeObjects[sRoad] = cylinder {sStart, sRoadMainPt1, RoadHalf}
			#local aLargeTextures[sRoad] = texture
			{
				sLargeSurface
				scale RoadWidth
				translate sPlane * RoadHalf + sStart
//				translate sPlane * RoadHalf + sMinStop + sTangent * (WalkDist - ShoulderWidth - BevelRadius)
//				#if (roadTyp = 1)
//					translate sTangent * ShoulderWidth
//				#end
			}

			// gap road sections
			#local aGapObjects[sRoad] = cylinder {sRoadMainPt1, sRoadMainPt2, RoadHalf}
			#local aGapTextures[sRoad] = texture
			{
				sRoadSurface
				scale RoadWidth
				translate sPlane * RoadHalf
			}

			// center road sections
			#if (sStopLength != 0)
				#local aCenterObjects[sRoad] = cylinder {sRoadMainPt2, 0, WalkHalf}
				#local aCenterTextures[sRoad] = texture
				{
					sRoadSurface
					scale RoadWidth
					translate sPlane * RoadHalf
				}
			#end

			// longer edge road sections
			#if (sEdgeLength != 0)
				#local aEdgeObjects[sRoad] = cylinder {sRoadEdgePt1, sRoadEdgePt2, ShoulderWidth/2}
				#local aEdgeTextures[sRoad] = texture
				{
					sRoadSurface
					scale RoadWidth
					translate sPlane * RoadHalf
				}
			#end

			// crosswalks
			#if (showCrs)
				#local aWalkObjects[sRoad] = cylinder {sCrosswalkPt1, sCrosswalkPt2, WalkWidth/2}
				#local aWalkTextures[sRoad] = texture
				{
					sWalkSurface
					scale WalkInterval
				}
			#end

			// corners
			#if (pParallel = 0)
				#local aCornerCutObjects[sRoad] = cylinder {pArcCenter - y * RoadHalf, pArcCenter + y * RoadHalf, pArcRadius};
				#local aCornerObjects[sRoad] = prism
				{
					#if (pAngle > 180)
						linear_spline -RoadHalf, +RoadHalf, 6
						<sCornerPt1.x, sCornerPt1.z,>, <spBevel.x, spBevel.z,>, <pIntersect.x, pIntersect.z,>, <psBevel.x, psBevel.z,>, <sCornerPt2.x, sCornerPt2.z,>, <sCornerPt4.x, sCornerPt4.z,>
					#else
						linear_spline -RoadHalf, +RoadHalf, 4
						<pArcCenter.x, pArcCenter.z,>, <sCornerPt1.x, sCornerPt1.z,>, <sCornerPt3.x, sCornerPt3.z,>, <sCornerPt2.x, sCornerPt2.z,>
					#end
				}
				#local aCornerTextures[sRoad] = texture
				{
					sCornerSurface
					#if (roadTyp = 0)
						scale RoadWidth
						translate sCornerInside
					#else
						scale RoadWidth + pRadius * 2
						translate pArcCenter
					#end
				}
			#end

			// embankments
			#if (showBed)
				#local sLegLength = tand(SlopeAngle) * LRoad_FudgeAmount;
				#local sDiagAngle = (180 - pAngle) / 2;
				#local sCrssMulti = tand(sDiagAngle) / sind(sDiagAngle);
				#local sCrssAngle = atan2d(sLegLength * sCrssMulti, LRoad_FudgeAmount);
				#local sCrssVector = vnormalize(pArcCenter);
				#local sCrssCross = vnormalize(vcross(sCrssVector, y));
				#local sCrssPlane = pArcCenter + (+sPlane - pPlane) * pArcRadius / 2;
				#local aWallMainObjects[sRoad] = intersection
				{
					plane {+sPlane, 0 Axis_Rotate_Trans(+sTangent, -SlopeAngle) translate + sPlane * RoadHalf}
					plane {-sPlane, 0 Axis_Rotate_Trans(+sTangent, +SlopeAngle) translate - sPlane * RoadHalf}
					plane {+sTangent, 0 translate sStart}
					plane {-sTangent, 0 translate sRoadMainPt3}
				}
				#if (roadTyp = 0)
					#local aWallCenterObjects[sRoad] = intersection
					{
						plane {+sPlane, 0 Axis_Rotate_Trans(+sTangent, -SlopeAngle) translate + sPlane * RoadHalf}
						plane {-sPlane, 0 Axis_Rotate_Trans(+sTangent, +SlopeAngle) translate - sPlane * RoadHalf}
						plane {+sTangent, 0 translate +sRoadMainPt3}
						plane {-sTangent, 0}
					}
					#if (pAngle > 180)
						#local aWallCornerObjects[sRoad] = intersection
						{
							plane {+sPlane, 0 Axis_Rotate_Trans(+sTangent, -SlopeAngle) translate + sPlane * RoadHalf}
							plane {-sPlane, 0 Axis_Rotate_Trans(+sTangent, +SlopeAngle) translate - sPlane * RoadHalf}
							plane {+pPlane, 0 Axis_Rotate_Trans(+pTangent, -SlopeAngle) translate + pPlane * RoadHalf}
							plane {-pPlane, 0 Axis_Rotate_Trans(+pTangent, +SlopeAngle) translate - pPlane * RoadHalf}
						}

					#else
						#local aWallCornerObjects[sRoad] = union {}
					#end
				#else
					#local aWallCenterObjects[sRoad] = intersection
					{
						plane {+sPlane, 0 translate + sPlane * RoadHalf}
						plane {-sPlane, 0 translate - sPlane * RoadHalf}
						plane {+sTangent, 0 translate +sRoadMainPt3}
						plane {-sTangent, 0 translate -sTangent * LRoad_FudgeAmount}
					}
					#local aWallCutObjectsB[sRoad] = cylinder {+y * LRoad_FudgeAmount, -y * LRoad_FudgeAmount, RoadHalf}
					#if (pAngle > 180)
						#local aWallCutObjectsA[sRoad] = cylinder {pArcCenter + y * LRoad_FudgeAmount, pArcCenter - y * LRoad_FudgeAmount, pArcRadius - ShoulderWidth}
						#local aWallCornerObjects[sRoad] = intersection
						{
							difference
							{
								cone {pArcCenter, pArcRadius, pArcCenter - y * LRoad_FudgeAmount, pArcRadius + sLegLength}
								cylinder {pArcCenter + y * LRoad_FudgeAmount, pArcCenter - y * LRoad_FudgeAmount, pArcRadius - ShoulderWidth}
							}
							plane {pArcCenter, VDist(((spBevel + sPlane * ShoulderWidth) + (psBevel - pPlane * ShoulderWidth)) / 2, 2)}
						}
					#else
						#local aWallCutObjectsA[sRoad] = cylinder {+y * LRoad_FudgeAmount, -y * LRoad_FudgeAmount, RoadWidth translate sMinIntersect}
						#local aWallCornerObjects[sRoad] = intersection
						{
							cylinder
							{
								+y * LRoad_FudgeAmount, -y * LRoad_FudgeAmount, pArcRadius
								Axial_Scale_Trans(+sCrssVector, cosd(sCrssAngle))
								Axis_Rotate_Trans(+sCrssCross, +sCrssAngle)
								translate pArcCenter
								inverse
							}
							plane {+sPlane, 0 Axis_Rotate_Trans(+sTangent, +SlopeAngle) translate - sPlane * RoadHalf}
							plane {-pPlane, 0 Axis_Rotate_Trans(+pTangent, -SlopeAngle) translate + pPlane * RoadHalf}
							plane {+vnormalize(pArcCenter), 0 Axis_Rotate_Trans(+sCrssCross, +sCrssAngle) translate sCrssPlane}
						}
					#end
				#end
			#end


			//----------------------------------------------------------------------------Debug

			#if (LRoad_Debug > 0)
				#debug concat("       sRoad = ", str(       sRoad, 0, +0), "\n")
				#debug concat("      pAngle = ", str(      pAngle, 0, -1), "\n")
				#debug concat("pBevelAdjust = ", str(pBevelAdjust, 0, -1), "\n")
				#debug concat("   pParallel = ", str(   pParallel, 0, +0), "\n")
				#debug concat(" sEdgeLength = ", str( sEdgeLength, 0, -1), "\n")
				#debug concat(" sStopLength = ", str( sStopLength, 0, -1), "\n")
				#debug concat("  pArcCenter = <", vstr(3, pArcCenter, ",", 0, -1), ">\n")
				#debug "\n"
			#end

			#if (LRoad_Debug > 1)
				cone   {  sMinStop, LRoad_DebugSize, sMinIntersect, 0	pigment {color rgb x+z}}
				cone   {  sMaxStop, LRoad_DebugSize, sMaxIntersect, 0	pigment {color rgb x}}
				cone   {  sNxtStop, LRoad_DebugSize, sNxtIntersect, 0	pigment {color rgb 0}}
				cone   {  sPrvStop, LRoad_DebugSize, sPrvIntersect, 0	pigment {color rgb 1}}
				cone   {   spBevel, LRoad_DebugSize, sCornerPt1, 0	pigment {color rgb y+z}}
				cone   {   psBevel, LRoad_DebugSize, sCornerPt2, 0	pigment {color rgb y+z}}
				sphere {  sMinStop, LRoad_DebugSize			pigment {color rgb x+z}}
				sphere {  sMaxStop, LRoad_DebugSize			pigment {color rgb x}}
				sphere {  sNxtStop, LRoad_DebugSize			pigment {color rgb 0}}
				sphere {  sPrvStop, LRoad_DebugSize			pigment {color rgb 1}}
				sphere {   spBevel, LRoad_DebugSize			pigment {color rgb y+z}}
				sphere {   psBevel, LRoad_DebugSize			pigment {color rgb y+z}}
				sphere {pArcCenter, LRoad_DebugSize			pigment {color rgb x+y}}
				sphere {pIntersect, LRoad_DebugSize			pigment {color rgb y}}
				sphere {  sNxtStop, LRoad_DebugSize			pigment {color rgb 0}}
				sphere {  sPrvStop, LRoad_DebugSize			pigment {color rgb 1}}
				sphere {         0, LRoad_DebugSize			pigment {color rgb z}}
				text
				{
					ttf "timrom.ttf" str(sRoad, 0, 0) LRoad_DebugSize, 0
					pigment { color rgb <1,0,0,> }
					scale <LRoad_DebugSize * 10, LRoad_DebugSize * 10, 1,>
					Reorient_Trans(z, sTangent)
					translate (sMaxStop + sMinStop) / 2
				}
			#end


			//----------------------------------------------------------------------------Count

			#local sRoad = sRoad + 1;
		#end

		#local sRoad = 0;
		#while (sRoad < roadNum)

			#local BigAngles = 0;
			#local iRoad = 0;
			#while (iRoad < roadNum)
				#if ((aSideAngles[iRoad] > 180) & (aParallelFlags[iRoad] = 0))
					#local BigAngles = BigAngles + 1;
				#end
				#local iRoad = iRoad + 1;
			#end


			//----------------------------------------------------------------------------Objects

			intersection
			{
				difference
				{
					object {aLargeObjects[sRoad]}
					#local iRoad = 0;
					#while (iRoad < roadNum)
						#if (showCrs)
							object {aWalkObjects[iRoad]}
						#end
						#local iRoad = iRoad + 1;
					#end
					bounded_by {object {aLargeObjects[sRoad]}}
				}
				object {PlaneMask}
				texture {aLargeTextures[sRoad]}
				bounded_by {object {aLargeObjects[sRoad]}}
			}
			intersection
			{
				difference
				{
					object {aGapObjects[sRoad]}
					#local iRoad = 0;
					#while (iRoad < roadNum)
						#if (showCrs)
							object {aWalkObjects[iRoad]}
						#end
						#local iRoad = iRoad + 1;
					#end
					bounded_by {object {aGapObjects[sRoad]}}
				}
				object {PlaneMask}
				texture {aGapTextures[sRoad]}
				bounded_by {object {aGapObjects[sRoad]}}
			}
			#if (aStopLengths[sRoad] != 0)
				intersection
				{
					difference
					{
						object {aCenterObjects[sRoad]}
						#local iRoad = 0;
						#while (iRoad < roadNum)
							#if (showCrs)
								object {aWalkObjects[iRoad]}
							#end
							#if (aParallelFlags[iRoad] = 0)
								object {aCornerObjects[iRoad]}
							#end
							#local iRoad = iRoad + 1;
						#end
						bounded_by {object {aCenterObjects[sRoad]}}
					}
					object {PlaneMask}
					texture {aCenterTextures[sRoad]}
					bounded_by {object {aCenterObjects[sRoad]}}
				}
			#end
			#if (aEdgeLengths[sRoad] != 0)
				intersection
				{
					difference
					{
						object {aEdgeObjects[sRoad]}
						#local iRoad = 0;
						#while (iRoad < roadNum)
							#if (showCrs)
								object {aWalkObjects[iRoad]}
							#end
							#local iRoad = iRoad + 1;
						#end
						bounded_by {object {aEdgeObjects[sRoad]}}
					}
					object {PlaneMask}
					texture {aEdgeTextures[sRoad]}
					bounded_by {object {aEdgeObjects[sRoad]}}
				}
			#end
			#if (aParallelFlags[sRoad] = 0)
				intersection
				{
					difference
					{
						#if (aSideAngles[sRoad] > 180)
							intersection
							{
								object {aCornerObjects[sRoad]}
								#if (roadTyp != 0)
									object {aCornerCutObjects[sRoad]}
								#end
							}
						#else
							difference
							{
								object {aCornerObjects[sRoad]}
								#if (roadTyp != 0)
									object {aCornerCutObjects[sRoad]}
								#end
							}
						#end
						#local iRoad = 0;
						#while (iRoad < roadNum)
							#if (showCrs)
								object {aWalkObjects[iRoad]}
							#end
							#if (aSideAngles[sRoad] > 180)
								object {aLargeObjects[iRoad]}
								object {aGapObjects[iRoad]}
								#if (aEdgeLengths[iRoad] != 0)
									object {aEdgeObjects[iRoad]}
								#end
								#if ((aParallelFlags[iRoad] = 0) & (iRoad != sRoad))
									object {aCornerObjects[iRoad]}
								#end
							#end
							#local iRoad = iRoad + 1;
						#end
						bounded_by {object {aCornerObjects[sRoad]}}
					}
					object {PlaneMask}
					texture {aCornerTextures[sRoad]}
					bounded_by {object {aCornerObjects[sRoad]}}
				}
			#end
			#if (showCrs)
				intersection
				{
					object {aWalkObjects[sRoad]}
					object {BedMask}
					texture {aWalkTextures[sRoad]}
					bounded_by {object {aWalkObjects[sRoad]}}
				}
			#end
			#if (showBed)
				intersection
				{
					union
					{
						object {aWallMainObjects[sRoad]}
						#if (aParallelFlags[sRoad] = 0)
							object {aWallCornerObjects[sRoad]}
						#end
						#if (roadTyp = 0)
							object {aWallCenterObjects[sRoad]}
						#else
							intersection
							{
								object {aWallCenterObjects[sRoad]}
								merge
								{
									#local iRoad = 0;
									#while (iRoad < roadNum)
										#if (BigAngles > 0)
											object {aWallCutObjectsA[iRoad]}
										#else
											object {aWallCutObjectsB[iRoad]}
										#end
										#local iRoad = iRoad + 1;
									#end
								}
							}
							#end
					}
					object {BedMask}
					texture {LRoad_EmbankmentTexture}
					scale 1 + 1/LRoad_FudgeAmount
					translate -y * 1/LRoad_FudgeAmount
				}
			#end

			#local sRoad = sRoad + 1;
		#end

		translate +y * roadHgh
	}
#end


//------------------------------------------------------------------------------Shaped road macro

#macro LRoad_Road_Macro
	(
		degrBeg,	// The starting tilt (banking) angle. Only applies if superelevation is disabled.	(float)
		degrEnd,	// The ending tilt (banking) angle. Only applies if superelevation is disabled.		(float)
				// ... Tilt (banking) angles are interpolated linearly at each step.
		roadShp,	// The road's shape.									(integer)
				// ... 0 is straight; 1 is ellipse; 2 is Nautilus spiral; 3 is Archimedes spiral; 4 is hermite spline.
		roadPrm,	// The shape-specific parameters.							(array)
				// ... Make sure to increment the array counter when adding or subtracting elements.
		stepTot,	// The total number of calculated steps.						(integer)
				// ... Should roughly equal the length of the road divided by the length of each stripe.
		stepBeg,	// The step number to begin rendering at.						(integer)
		stepEnd,	// The step number to end rendering at.							(integer)
		roadBnk,	// Enable/disable superelevation (road banking).					(bool)
		spLimit,	// The speed limit (mph). Only applies if superelevation is enabled.			(float)
		roadTyp,	// The type of road. 0 = "9-Stud"; 1 = "8-Stud"; 2 = "7-Stud".				(integer)
		showBed,	// Enable/disable road embankments.							(boolean)
	)

	#if (LRoad_Debug > 0)
		#debug "\n"
	#end
	#if (roadShp > 4)
		#error "The road shape must be 0, 1, 2, 3 or 4.\n"
	#end
	#if (roadTyp > 2)
		#error "The type of road must be 0, 1 or 2.\n"
	#end
	#if ((showBed > 1) | (showBed < 0))
		#error "Disable/Enable embankments by specifying 0 or 1, on or off, yes or no.\n"
	#end
	#if ((roadBnk > 1) | (roadBnk < 0))
		#error "Disable/Enable supereleveation by specifying 0 or 1, on or off, yes or no.\n"
	#end


	//------------------------------------------------------------------------------Variables

	#switch (roadShp)
		#case (0)						// Straight
			#local   OrigPnt = roadPrm[0];			// Starting point.									(vector)
			#local   DestPnt = roadPrm[1];			// Ending point.									(vector)
			#local   VectPnt = DestPnt - OrigPnt;
		#break
		#case (1)						// Ellipse
			#local   MajAxis = roadPrm[0];			// The length of the ellipse's semi-major axis.						(float)
			#local   MinAxis = roadPrm[1];			// The length of the ellipse's semi-minor axis.						(float)
			#local HeightBeg = roadPrm[2]; 			// The starting height.									(float)
			#local HeightEnd = roadPrm[3]; 			// The ending height. Generates a "corkscrew" effect if not equal to zero.		(float)
			#local HeightDif = HeightEnd - HeightBeg;	// The difference betwen the ending height and the starting height.			(float)
			#local      TBeg = roadPrm[4];			// The starting "t" value. Typically equal to zero.					(float, typically between 0 and 1)
			#local      TEnd = roadPrm[5];			// The ending "t" value. Typically equal to one.					(float, typically between 0 and 1)
		#break
		#case (2)						// Nautilus spiral
			#local RadiusSpi = roadPrm[0];			// The radius of the spiral at step #0.							(float)
			#local HeightBeg = roadPrm[1]; 			// The starting height.									(float)
			#local HeightEnd = roadPrm[2]; 			// The ending height. Generates a "corkscrew" effect if not equal to zero.		(float)
			#local HeightDif = HeightEnd - HeightBeg;	// The difference betwen the ending height and the starting height.			(float)
			#local  DevAngle = radians(roadPrm[3]);		// The angle at which the path of the spiral deviates from its previous vector.		(float, degrees)
									// Valid values range between 0 and 180 degrees. If 90 degrees, then a circle is generated.
									// A value of 0 (zero) causes POV-Ray to crash.
			#local      TBeg = roadPrm[4];			// The starting "t" value. Typically equal to zero.					(float, typically between 0 and 1)
			#local      TEnd = roadPrm[5];			// The ending "t" value. Typically equal to one.					(float, typically between 0 and 1)
			#if (roadPrm[6]) 				// Reverse the spiral's direction?							(boolean)
				#local Direct = -1;
			#else
				#local Direct = +1;
			#end
		#break
		#case (3)						// Archimedes spiral
			#local RadiusSpi = roadPrm[0];			// The radius of the spiral at step #0.							(float)
			#local HeightBeg = roadPrm[1]; 			// The starting height.									(float)
			#local HeightEnd = roadPrm[2]; 			// The ending height. Generates a "corkscrew" effect if not equal to zero.		(float)
			#local HeightDif = HeightEnd - HeightBeg;	// The difference betwen the ending height and the starting height.			(float)
			#local      TBeg = roadPrm[3];			// The starting "t" value. Typically equal to zero.					(float, typically between 0 and 1)
			#local      TEnd = roadPrm[4];			// The ending "t" value. Typically equal to one.					(float, typically between 0 and 1)
			#if (roadPrm[5])				// Reverse the spiral's direction?							(boolean)
				#local Direct = -1;
			#else
				#local Direct = +1;
			#end
		#break
		#case (4)						// Hermite spline
			#local splineTot = dimension_size(roadPrm,1) / 2 - 1;	// The number of splines.
			#if (LRoad_Debug > 0)
				#debug concat("splineTot = ", str(splineTot, 0, 0), "\n")
			#end
		#break
	#end

	#local     MaxAngle = 0;
	#local      MaxStep = 0;
	#local     AvgSpeed = f_sqr(spLimit * 5280 / 3600 / LRoad_DistanceUnit);
	#local    RoadWidth = LRoad_RoadWidth[roadTyp];			// The width of the road.
	#local StripeInterval = LRoad_StripeInterval[roadTyp];		// The distance between each stripe-interval.
	#local   SlopeAngle = 90 - atan2d(LRoad_WallSlope, 1);		// The angle of the embankment's slope.
	#local     RoadHalf = RoadWidth / 2;				// Half the width of the road.
	#ifdef (HeightBeg)
		#local FloorObject = object {LRoad_FloorObject translate -LRoad_SkyVector * HeightBeg};
	#else
		#local FloorObject = object {LRoad_FloorObject};
	#end

	#local stepDif = stepEnd - stepBeg;
	#if (LRoad_Debug > 1)
		#local          aPos = array[stepDif];
		#local      aTangent = array[stepDif];
		#local        aPlane = array[stepDif];
		#local        aAngle = array[stepDif];
		#local         aTilt = array[stepDif];
		#local         aLeft = array[stepDif];
		#local        aRight = array[stepDif];
		#local     aLeftNorm = array[stepDif];
		#local    aRightNorm = array[stepDif];
		#local      aLeftTop = array[stepDif];
		#local     aRightTop = array[stepDif];
		#local      aLeftBot = array[stepDif];
		#local     aRightBot = array[stepDif];
		#local  aLeftTopNorm = array[stepDif];
		#local aRightTopNorm = array[stepDif];
		#local  aLeftBotNorm = array[stepDif];
		#local aRightBotNorm = array[stepDif];
	#end

	union
	{
		mesh
		{
			#local stepNow = stepBeg;
			#while (stepNow < stepEnd)

				#if (LRoad_Debug > 0)
					#debug concat("stepNow = ", str(stepNow, 0, 0), "\n")
				#end


				//------------------------------------------------------------------------------Curve parameters

				#local  pppTime = (stepNow - 3) / stepTot;
				#local   ppTime = (stepNow - 2) / stepTot;
				#local    pTime = (stepNow - 1) / stepTot;
				#local    sTime = (stepNow - 0) / stepTot;
				#local    nTime = (stepNow + 1) / stepTot;
				#local   nnTime = (stepNow + 2) / stepTot;
				#local  nnnTime = (stepNow + 3) / stepTot;
				#local nnnnTime = (stepNow + 4) / stepTot;

				#if (LRoad_Debug > 0)
					#debug concat("sTime = ", str(sTime, 0, -1), "\n")
				#end

				#switch (roadShp)
					#case (0)
						#local  pppPos = LRoad_Pos_Straight(VectPnt,OrigPnt, pppTime);
						#local   ppPos = LRoad_Pos_Straight(VectPnt,OrigPnt,  ppTime);
						#local    pPos = LRoad_Pos_Straight(VectPnt,OrigPnt,   pTime);
						#local    sPos = LRoad_Pos_Straight(VectPnt,OrigPnt,   sTime);
						#local    nPos = LRoad_Pos_Straight(VectPnt,OrigPnt,   nTime);
						#local   nnPos = LRoad_Pos_Straight(VectPnt,OrigPnt,  nnTime);
						#local  nnnPos = LRoad_Pos_Straight(VectPnt,OrigPnt, nnnTime);
						#local nnnnPos = LRoad_Pos_Straight(VectPnt,OrigPnt,nnnnTime);
					#break
					#case (1)
						#local  pppPos = LRoad_Pos_Ellipse(HeightDif,MajAxis,MinAxis,TBeg,TEnd, pppTime);
						#local   ppPos = LRoad_Pos_Ellipse(HeightDif,MajAxis,MinAxis,TBeg,TEnd,  ppTime);
						#local    pPos = LRoad_Pos_Ellipse(HeightDif,MajAxis,MinAxis,TBeg,TEnd,   pTime);
						#local    sPos = LRoad_Pos_Ellipse(HeightDif,MajAxis,MinAxis,TBeg,TEnd,   sTime);
						#local    nPos = LRoad_Pos_Ellipse(HeightDif,MajAxis,MinAxis,TBeg,TEnd,   nTime);
						#local   nnPos = LRoad_Pos_Ellipse(HeightDif,MajAxis,MinAxis,TBeg,TEnd,  nnTime);
						#local  nnnPos = LRoad_Pos_Ellipse(HeightDif,MajAxis,MinAxis,TBeg,TEnd, nnnTime);
						#local nnnnPos = LRoad_Pos_Ellipse(HeightDif,MajAxis,MinAxis,TBeg,TEnd,nnnnTime);
					#break
					#case (2)
						#local  pppPos = LRoad_Pos_Nautilus(HeightDif,Direct,DevAngle,RadiusSpi,TBeg,TEnd, pppTime);
						#local   ppPos = LRoad_Pos_Nautilus(HeightDif,Direct,DevAngle,RadiusSpi,TBeg,TEnd,  ppTime);
						#local    pPos = LRoad_Pos_Nautilus(HeightDif,Direct,DevAngle,RadiusSpi,TBeg,TEnd,   pTime);
						#local    sPos = LRoad_Pos_Nautilus(HeightDif,Direct,DevAngle,RadiusSpi,TBeg,TEnd,   sTime);
						#local    nPos = LRoad_Pos_Nautilus(HeightDif,Direct,DevAngle,RadiusSpi,TBeg,TEnd,   nTime);
						#local   nnPos = LRoad_Pos_Nautilus(HeightDif,Direct,DevAngle,RadiusSpi,TBeg,TEnd,  nnTime);
						#local  nnnPos = LRoad_Pos_Nautilus(HeightDif,Direct,DevAngle,RadiusSpi,TBeg,TEnd, nnnTime);
						#local nnnnPos = LRoad_Pos_Nautilus(HeightDif,Direct,DevAngle,RadiusSpi,TBeg,TEnd,nnnnTime);
					#break
					#case (3)
						#local  pppPos = LRoad_Pos_Archimedes(HeightDif,Direct,RadiusSpi,TBeg,TEnd, pppTime);
						#local   ppPos = LRoad_Pos_Archimedes(HeightDif,Direct,RadiusSpi,TBeg,TEnd,  ppTime);
						#local    pPos = LRoad_Pos_Archimedes(HeightDif,Direct,RadiusSpi,TBeg,TEnd,   pTime);
						#local    sPos = LRoad_Pos_Archimedes(HeightDif,Direct,RadiusSpi,TBeg,TEnd,   sTime);
						#local    nPos = LRoad_Pos_Archimedes(HeightDif,Direct,RadiusSpi,TBeg,TEnd,   nTime);
						#local   nnPos = LRoad_Pos_Archimedes(HeightDif,Direct,RadiusSpi,TBeg,TEnd,  nnTime);
						#local  nnnPos = LRoad_Pos_Archimedes(HeightDif,Direct,RadiusSpi,TBeg,TEnd, nnnTime);
						#local nnnnPos = LRoad_Pos_Archimedes(HeightDif,Direct,RadiusSpi,TBeg,TEnd,nnnnTime);
					#break
					#case (4)
						#local  pppTime2 =  pppTime * splineTot;
						#local   ppTime2 =   ppTime * splineTot;
						#local    pTime2 =    pTime * splineTot;
						#local    sTime2 =    sTime * splineTot;
						#local    nTime2 =    nTime * splineTot;
						#local   nnTime2 =   nnTime * splineTot;
						#local  nnnTime2 =  nnnTime * splineTot;
						#local nnnnTime2 = nnnnTime * splineTot;
						#if (LRoad_Debug > 0)
							#debug concat("sTime2 = ", str(sTime2, 0, -1), "\n")
						#end
						#local  pppSpline = min(splineTot - 1,max(0,floor( pppTime2)));
						#local   ppSpline = min(splineTot - 1,max(0,floor(  ppTime2)));
						#local    pSpline = min(splineTot - 1,max(0,floor(   pTime2)));
						#local    sSpline = min(splineTot - 1,max(0,floor(   sTime2)));
						#local    nSpline = min(splineTot - 1,max(0,floor(   nTime2)));
						#local   nnSpline = min(splineTot - 1,max(0,floor(  nnTime2)));
						#local  nnnSpline = min(splineTot - 1,max(0,floor( nnnTime2)));
						#local nnnnSpline = min(splineTot - 1,max(0,floor(nnnnTime2)));
						#if (LRoad_Debug > 0)
							#debug concat("sSpline = ", str(sSpline, 0, 0), "\n")
						#end
						#local  pppTime3 =  pppTime2 -  pppSpline;
						#local   ppTime3 =   ppTime2 -   ppSpline;
						#local    pTime3 =    pTime2 -    pSpline;
						#local    sTime3 =    sTime2 -    sSpline;
						#local    nTime3 =    nTime2 -    nSpline;
						#local   nnTime3 =   nnTime2 -   nnSpline;
						#local  nnnTime3 =  nnnTime2 -  nnnSpline;
						#local nnnnTime3 = nnnnTime2 - nnnnSpline;
						#if (LRoad_Debug > 0)
							#debug concat("sTime3 = ", str(sTime3, 0, -1), "\n")
						#end
						#local  pppEndPt = ( pppSpline + 1) * 2;
						#local   ppEndPt = (  ppSpline + 1) * 2;
						#local    pEndPt = (   pSpline + 1) * 2;
						#local    sEndPt = (   sSpline + 1) * 2;
						#local    nEndPt = (   nSpline + 1) * 2;
						#local   nnEndPt = (  nnSpline + 1) * 2;
						#local  nnnEndPt = ( nnnSpline + 1) * 2;
						#local nnnnEndPt = (nnnnSpline + 1) * 2;
						#if (LRoad_Debug > 0)
							#debug concat("sEndPt = ", str(sEndPt, 0, 0), "\n")
						#end
						#local  pppPos = LRoad_Pos_Spline(roadPrm[ pppEndPt - 2],roadPrm[ pppEndPt - 1],roadPrm[ pppEndPt + 0],roadPrm[ pppEndPt + 1], pppTime3);
						#local   ppPos = LRoad_Pos_Spline(roadPrm[  ppEndPt - 2],roadPrm[  ppEndPt - 1],roadPrm[  ppEndPt + 0],roadPrm[  ppEndPt + 1],  ppTime3);
						#local    pPos = LRoad_Pos_Spline(roadPrm[   pEndPt - 2],roadPrm[   pEndPt - 1],roadPrm[   pEndPt + 0],roadPrm[   pEndPt + 1],   pTime3);
						#local    sPos = LRoad_Pos_Spline(roadPrm[   sEndPt - 2],roadPrm[   sEndPt - 1],roadPrm[   sEndPt + 0],roadPrm[   sEndPt + 1],   sTime3);
						#local    nPos = LRoad_Pos_Spline(roadPrm[   nEndPt - 2],roadPrm[   nEndPt - 1],roadPrm[   nEndPt + 0],roadPrm[   nEndPt + 1],   nTime3);
						#local   nnPos = LRoad_Pos_Spline(roadPrm[  nnEndPt - 2],roadPrm[  nnEndPt - 1],roadPrm[  nnEndPt + 0],roadPrm[  nnEndPt + 1],  nnTime3);
						#local  nnnPos = LRoad_Pos_Spline(roadPrm[ nnnEndPt - 2],roadPrm[ nnnEndPt - 1],roadPrm[ nnnEndPt + 0],roadPrm[ nnnEndPt + 1], nnnTime3);
						#local nnnnPos = LRoad_Pos_Spline(roadPrm[nnnnEndPt - 2],roadPrm[nnnnEndPt - 1],roadPrm[nnnnEndPt + 0],roadPrm[nnnnEndPt + 1],nnnnTime3);
					#break
				#end

				#local  ppTangent =    pPos - pppPos;
				#local   pTangent =    sPos -  ppPos;
				#local   sTangent =    nPos -   pPos;
				#local   nTangent =   nnPos -   sPos;
				#local  nnTangent =  nnnPos -   nPos;
				#local nnnTangent = nnnnPos -  nnPos;

				#local  ppPlane = vnormalize(vcross( ppTangent, y)) * RoadHalf;
				#local   pPlane = vnormalize(vcross(  pTangent, y)) * RoadHalf;
				#local   sPlane = vnormalize(vcross(  sTangent, y)) * RoadHalf;
				#local   nPlane = vnormalize(vcross(  nTangent, y)) * RoadHalf;
				#local  nnPlane = vnormalize(vcross( nnTangent, y)) * RoadHalf;
				#local nnnPlane = vnormalize(vcross(nnnTangent, y)) * RoadHalf;

				#local  pAngle = degrBeg - (degrBeg - degrEnd) *  pTime;
				#local  sAngle = degrBeg - (degrBeg - degrEnd) *  sTime;
				#local  sAngle = degrBeg - (degrBeg - degrEnd) *  nTime;
				#local nAngle = degrBeg - (degrBeg - degrEnd) * nnTime;

				#local  pTilt = vaxis_rotate( pPlane,  pTangent,  pAngle);
				#local  sTilt = vaxis_rotate( sPlane,  sTangent,  sAngle);
				#local  nTilt = vaxis_rotate( nPlane,  nTangent,  sAngle);
				#local nnTilt = vaxis_rotate(nnPlane, nnTangent, nAngle);


				//------------------------------------------------------------------------------Superelevation calculations

				#if ((roadShp != 0) & (roadBnk))
					#local temparray = LRoad_ln2ln(<ppPos.x,0,ppPos.z,>,<ppPlane.x,0,ppPlane.z,>,<  pPos.x,0,  pPos.z,>,<  pPlane.x,0,   pPlane.z,>);
					#local   p_ppIntersect = temparray[0];
					#local temparray = LRoad_ln2ln(< sPos.x,0, sPos.z,>,< sPlane.x,0, sPlane.z,>,<  pPos.x,0,  pPos.z,>,<  pPlane.x,0,   pPlane.z,>);
					#local    s_pIntersect = temparray[0];
					#local temparray = LRoad_ln2ln(< sPos.x,0, sPos.z,>,< sPlane.x,0, sPlane.z,>,<  nPos.x,0,  nPos.z,>,<  nPlane.x,0,   nPlane.z,>);
					#local    s_sIntersect = temparray[0];
					#local temparray = LRoad_ln2ln(<nnPos.x,0,nnPos.z,>,<nnPlane.x,0,nnPlane.z,>,<  nPos.x,0,  nPos.z,>,<  nPlane.x,0,   nPlane.z,>);
					#local   n_nIntersect = temparray[0];
					#local temparray = LRoad_ln2ln(<nnPos.x,0,nnPos.z,>,<nnPlane.x,0,nnPlane.z,>,<nnnPos.x,0,nnnPos.z,>,<nnnPlane.x,0, nnnPlane.z,>);
					#local nn_nnIntersect = temparray[0];

					#local  pAvgIntersect = ( s_pIntersect +   p_ppIntersect) / 2;
					#local  sAvgIntersect = ( s_pIntersect +    s_sIntersect) / 2;
					#local  nAvgIntersect = (n_nIntersect +    s_sIntersect) / 2;
					#local nnAvgIntersect = (n_nIntersect + nn_nnIntersect) / 2;

					#local  pRadius = VDist( pPos,  pAvgIntersect) / 20;
					#local  sRadius = VDist( sPos,  sAvgIntersect) / 20;
					#local  nRadius = VDist( nPos,  nAvgIntersect) / 20;
					#local nnRadius = VDist(nnPos, nnAvgIntersect) / 20;

					#local  pAngle = degrees(atan2(AvgSpeed / ( pRadius * 32.2), 1));
					#local  sAngle = degrees(atan2(AvgSpeed / ( sRadius * 32.2), 1));
					#local  sAngle = degrees(atan2(AvgSpeed / ( nRadius * 32.2), 1));
					#local nAngle = degrees(atan2(AvgSpeed / (nnRadius * 32.2), 1));

					#local  pTilt = vaxis_rotate( pPlane,  pTangent,  pAngle);
					#local  sTilt = vaxis_rotate( sPlane,  sTangent,  sAngle);
					#local  nTilt = vaxis_rotate( nPlane,  nTangent,  sAngle);
					#local nnTilt = vaxis_rotate(nnPlane, nnTangent, nAngle);

					#if (LRoad_Debug > 0)
						#debug concat("sAngle = ", str(sAngle, 0, -1), "\n")
						#if (abs(sAngle) > MaxAngle)
							#local MaxAngle =  sAngle;
							#local MaxStep = stepNow;
						#end
					#end
				#end


				//------------------------------------------------------------------------------Triangle parameters

				#local  sLeft = sPos + sTilt;
				#local sRight = sPos - sTilt;
				#local  nLeft = nPos + nTilt;
				#local nRight = nPos - nTilt;

				#local  sLeftNorm = -vnormalize((vcross(sTangent,sTilt) + vcross(pTangent,sTilt) + vcross(pTangent, pTilt)) / 3);
				#local sRightNorm = -vnormalize((vcross(pTangent,sTilt) + vcross(sTangent,sTilt) + vcross(sTangent, nTilt)) / 3);
				#local  nLeftNorm = -vnormalize((vcross(sTangent,nTilt) + vcross(sTangent,sTilt) + vcross(nTangent, nTilt)) / 3);
				#local nRightNorm = -vnormalize((vcross(sTangent,nTilt) + vcross(nTangent,nTilt) + vcross(nTangent,nnTilt)) / 3);

				#local sRotateVec = vnormalize(vcross(sPlane,LRoad_SkyVector));
				#local nRotateVec = vnormalize(vcross(nPlane,LRoad_SkyVector));

				#local  sLeftRotate = vaxis_rotate(LRoad_SkyVector,sRotateVec,+SlopeAngle);
				#local sRightRotate = vaxis_rotate(LRoad_SkyVector,sRotateVec,-SlopeAngle);
				#local  nLeftRotate = vaxis_rotate(LRoad_SkyVector,nRotateVec,+SlopeAngle);
				#local nRightRotate = vaxis_rotate(LRoad_SkyVector,nRotateVec,-SlopeAngle);

				#local  sLeftTop =  sLeft;
				#local sRightTop = sRight;
				#local  nLeftTop =  nLeft;
				#local nRightTop = nRight;

				#local  sLeftBot = trace(FloorObject, sLeft, -sLeftRotate);
				#local sRightBot = trace(FloorObject,sRight,-sRightRotate);
				#local  nLeftBot = trace(FloorObject, nLeft, -nLeftRotate);
				#local nRightBot = trace(FloorObject,nRight,-nRightRotate);

				#local  sLeftTopNorm = vnormalize(vcross(-sRotateVec,  sLeftTop -  sLeftBot));
				#local sRightTopNorm = vnormalize(vcross(-sRotateVec, sRightBot - sRightTop));
				#local  nLeftTopNorm = vnormalize(vcross(-nRotateVec,  nLeftTop -  nLeftBot));
				#local nRightTopNorm = vnormalize(vcross(-nRotateVec, nRightBot - nRightTop));

				#local  sLeftBotNorm = vnormalize(vcross(-sRotateVec,  sLeftTop -  sLeftBot));
				#local sRightBotNorm = vnormalize(vcross(-sRotateVec, sRightBot - sRightTop));
				#local  nLeftBotNorm = vnormalize(vcross(-nRotateVec,  nLeftTop -  nLeftBot));
				#local nRightBotNorm = vnormalize(vcross(-nRotateVec, nRightBot - nRightTop));

				//----------------------------------------------------------------------------Textures
		
				#local sStripeSurface = texture
				{
					gradient (nPos - sPos)
					LRoad_StripeSurface(roadTyp)
					scale StripeInterval/RoadWidth
				}
				#local sRoadSurface = texture
				{
					gradient (nTilt + sTilt)
					LRoad_RoadSurface(roadTyp)
				}
				#local RoadTexture = texture
				{
					gradient (nTilt + sTilt)
					LRoad_RoadMap(roadTyp, sRoadSurface, sStripeSurface)
					scale RoadWidth
					translate nPos
					translate nTilt
				}
				#local WallTexture = texture
				{
					LRoad_EmbankmentTexture
				}


				//----------------------------------------------------------------------------Triangles

				smooth_triangle { sLeft,  sLeftNorm,  nLeft,  nLeftNorm, sRight, sRightNorm	texture {RoadTexture}}
				smooth_triangle {sRight, sRightNorm, nRight, nRightNorm,  nLeft,  nLeftNorm	texture {RoadTexture}}

				#if (showBed)

					#switch (stepNow)
						#case (0)
							triangle { sLeftTop, sRightTop,  sLeftBot	texture {WallTexture}}
							triangle {sRightTop, sRightBot,  sLeftBot	texture {WallTexture}}
						#break
						#case (stepEnd - 1)
							triangle { nLeftTop, nRightTop,  nLeftBot	texture {WallTexture}}
							triangle {nRightTop, nRightBot,  nLeftBot	texture {WallTexture}}
						#break
					#end
	
					smooth_triangle { nLeftTop,  nLeftTopNorm,  sLeftTop,  sLeftTopNorm,  sLeftBot,  sLeftBotNorm	texture {WallTexture}}
					smooth_triangle {nRightTop, nRightTopNorm, sRightTop, sRightTopNorm, sRightBot, sRightBotNorm	texture {WallTexture}}
					smooth_triangle { nLeftTop,  nLeftTopNorm,  nLeftBot,  nLeftBotNorm,  sLeftBot,  sLeftBotNorm	texture {WallTexture}}
					smooth_triangle {nRightTop, nRightTopNorm, nRightBot, nRightBotNorm, sRightBot, sRightBotNorm	texture {WallTexture}}
					smooth_triangle { sLeftBot,  sLeftBotNorm,  nLeftBot,  nLeftBotNorm, sRightBot, sRightBotNorm	texture {WallTexture}}
					smooth_triangle {sRightBot, sRightBotNorm, nRightBot, nRightBotNorm,  nLeftBot,  nLeftBotNorm	texture {WallTexture}}

				#end


				//----------------------------------------------------------------------------Store and count

				#local stepDif = stepNow - stepBeg;
				#if (LRoad_Debug > 1)
					#local          aPos[stepDif] =          sPos;
					#local      aTangent[stepDif] =      sTangent;
					#local        aPlane[stepDif] =        sPlane;
					#local        aAngle[stepDif] =        sAngle;
					#local         aTilt[stepDif] =         sTilt;
					#local         aLeft[stepDif] =         sLeft;
					#local        aRight[stepDif] =        sRight;
					#local     aLeftNorm[stepDif] =     sLeftNorm;
					#local    aRightNorm[stepDif] =    sRightNorm;
					#local      aLeftTop[stepDif] =      sLeftTop;
					#local     aRightTop[stepDif] =     sRightTop;
					#local      aLeftBot[stepDif] =      sLeftBot;
					#local     aRightBot[stepDif] =     sRightBot;
					#local  aLeftTopNorm[stepDif] =  sLeftTopNorm;
					#local aRightTopNorm[stepDif] = sRightTopNorm;
					#local  aLeftBotNorm[stepDif] =  sLeftBotNorm;
					#local aRightBotNorm[stepDif] = sRightBotNorm;
				#end
				#if (LRoad_Debug > 0)
					#debug "\n"
				#end
				#local stepNow = stepNow + 1;
			#end

			inside_vector vnormalize(LRoad_SkyVector)
		}


		//------------------------------------------------------------------------------Debug marker objects

		#if (LRoad_Debug > 1)

			#local stepNow = stepBeg;
			#while (stepNow < stepEnd)
				#local stepDif = stepNow - stepBeg;

				#local          sPos =          aPos[stepDif];
				#local      sTangent =      aTangent[stepDif];
				#local        sPlane =        aPlane[stepDif];
				#local        sAngle =        aAngle[stepDif];
				#local         sTilt =         aTilt[stepDif];
				#local         sLeft =         aLeft[stepDif];
				#local        sRight =        aRight[stepDif];
				#local     sLeftNorm =     aLeftNorm[stepDif];
				#local    sRightNorm =    aRightNorm[stepDif];
				#local      sLeftTop =      aLeftTop[stepDif];
				#local     sRightTop =     aRightTop[stepDif];
				#local      sLeftBot =      aLeftBot[stepDif];
				#local     sRightBot =     aRightBot[stepDif];
				#local  sLeftTopNorm =  aLeftTopNorm[stepDif];
				#local sRightTopNorm = aRightTopNorm[stepDif];
				#local  sLeftBotNorm =  aLeftBotNorm[stepDif];
				#local sRightBotNorm = aRightBotNorm[stepDif];

				// Cones marking the Tangent vectors.
				cone {sPos, LRoad_DebugSize, sPos + sTangent, 0					pigment {color rgb z}}

				// Cones marking the Plane vectors.
				cone {sPos, LRoad_DebugSize, sPos +   sPlane, 0					pigment {color rgb y}}

				// Cones marking the surface normals.
				cone { sLeft, LRoad_DebugSize,  sLeft +  sLeftNorm * RoadWidth/4, 0		pigment {color rgb x+y}}
				cone {sRight, LRoad_DebugSize, sRight + sRightNorm * RoadWidth/4, 0		pigment {color rgb x+y}}

				// Cones marking embankment normals.
				cone { sLeftTop, LRoad_DebugSize,  sLeftTop +  sLeftTopNorm * RoadWidth/4, 0	pigment {color rgb x+y}}
				cone {sRightTop, LRoad_DebugSize, sRightTop + sRightTopNorm * RoadWidth/4, 0	pigment {color rgb x+y}}
				cone { sLeftBot, LRoad_DebugSize,  sLeftBot +  sLeftBotNorm * RoadWidth/4, 0	pigment {color rgb x+y}}
				cone {sRightBot, LRoad_DebugSize, sRightBot + sRightBotNorm * RoadWidth/4, 0	pigment {color rgb x+y}}

				// Step number written in text at each step.
				text
				{
					ttf "timrom.ttf" str(stepNow, 0, 0) LRoad_DebugSize, 0
					pigment { color rgb <1,0,0,> }
					scale <LRoad_DebugSize * 10, LRoad_DebugSize * 10, 1,>
					Reorient_Trans(z, sTangent)
					translate sPos
				}

				#local stepNow = stepNow + 1;
			#end
		#end

		#ifdef (HeightBeg)
			translate +LRoad_SkyVector * HeightBeg
		#end
	}

	#if (LRoad_Debug > 0)
		#debug concat("\nMaximum recorded banking angle = +/-", str(MaxAngle, 0, -1), " at step #", str(MaxStep, 0, 0), ".\n\n")
	#end
#end
